/**
 * Stores all the parameters needed to define
 * a particular simulation instance
 * 
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class SimulationParams {

	private String paramsFileName;
	private double mediumLength;
	private double mediumWidth;
	private double mediumHeight;
	private ArrayList<Position> transmitterPositions;
	private double transmitterRadius;
	private ArrayList<Position> receiverPositions;
	private double receiverRadius;
	private ArrayList<Position> intermediateNodePositions;
	private double intermediateNodeRadius;
	private ArrayList<MicrotubulePosition> microtubuleEndPoints;
	private ArrayList<Double> microtubuleRadii;
	private int numMessages;
	private int maxNumSteps;
	private int numRetransmissions;
	private int retransmitWaitTime;
	private boolean useCollisions;
	private ArrayList<MoleculeParams> moleculeParams;
	private double molRandMoveX;
	private double molRandMoveY;
	private double molRandMoveZ;
	private double velRail;
	private double probDRail;

	public int getMaxNumSteps() {
		return maxNumSteps;
	}

	public int getNumMessages() {
		return numMessages;
	}

	public SimulationParams(String[] args) {
		parseArgs(args);
		readParamsFile(paramsFileName);
	}

	private void parseArgs(String[] args) {
		/*parses command line arguments, stores them in fields
	args can include type of movement for acknowledgement, information, and noise molecules (passive = default for info and ack, stationary = default for noise).  Indicated with: -(tx|rx|no): (active|passive|stationary) (where no stands for noise)
	args can include type of Automatic Repeat Request scheme used (currently none is default, for no acknowledgement molecules, change to sw11 later).  Indicated with: arq: (sw)(1..n),(1..m) , where sw means stop-and-wait (might implement 
	other ARQ schemes later, the next integer value represents the number of information molecules to send (minimum 1), and the next integer value represents the number of acknowledgement molecules to send.
	args can include input file location/name (default: params.dat).  Indicated with: pfile:<string>.  paramsFile must be set up in parseArgs, but not opened for reading.*/
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	private void readParamsFile(String fName) {
		/*open params file for reading
	Reads params from paramsFile (field), each param type is identified by the first string starting a line, although its values may extend over multiple lines (for example, to make it easier to view arrays of things).  Stores each paramâ€™s value(s) in a
 	private field.  Alternatively, we could do this with a hashmap of key, value pairs, where the key is the String representing the name of the parameter and the value is of Object type so it can be anything we want.  Not sure which is the better way
 	to go.  
	close param file for reading*/
		/*LEGACY CODE*/
		//TODO: Can this be improved?
		//TODO: Make sure all parameters are accounted for and line up between file and this method
		boolean flag = true;
		
		String line;
		BufferedReader br = new BufferedReader(new FileReader(fName));
		while((line = br.readLine())!=null){
			String param = "";
			if(!line.equals(""))
				param = line.substring(line.indexOf(" ")+1).trim();
			if(line.startsWith("stepLengthX")){
				molRandMoveX = Double.parseDouble(param);
			}
			else if(line.startsWith("stepLengthY")){
				molRandMoveY = Double.parseDouble(param);
			}
			else if(line.startsWith("stepLengthZ")){
				molRandMoveZ = Double.parseDouble(param);
			}
			else if(line.startsWith("mediumDimensionX")){
				mediumLength = Double.parseDouble(param);
			}
			else if(line.startsWith("mediumDimensionY")){
				mediumWidth = Double.parseDouble(param);				
			}
			else if(line.startsWith("mediumDimensionZ")){
				mediumHeight = Double.parseDouble(param);
			}
			else if(line.startsWith("maxSimulationTime")){
				maxSimulationTime = Double.parseDouble(param);
			}
			
			else if (line.startsWith("maxSimulationStep")){
				maxSimulationStep = Double.parseDouble(param);
				
			}
			else if(line.startsWith("noOfMolecules")){
				noOfMolecules = Integer.parseInt(param);
			}
			else if(line.startsWith("distSendReciever")){
				distSendReciever = Double.parseDouble(param);
				sender.setX(-distSendReciever/2);
				sender.setY(0);
				sender.setZ(0);
				reciever.setX(distSendReciever/2);
				reciever.setY(0);
				reciever.setZ(0);
				flag = false;
			}
			else if(line.startsWith("senderPosition") && flag){
				sender.setX(Double.parseDouble(param.substring(1,param.indexOf(delim))));
				sender.setY(Double.parseDouble(param.substring(
						param.indexOf(delim)+1, 
						param.indexOf(delim, param.indexOf(delim)+1)
						)));
				sender.setZ(Double.parseDouble(param.substring(
						param.indexOf(delim, param.indexOf(delim)+1)+1, 
						param.length()-1
						)));
			}
			else if(line.startsWith("recieverCenter") && flag){
				reciever.setX(Double.parseDouble(param.substring(1,param.indexOf(delim))));
				reciever.setY(Double.parseDouble(param.substring(
						param.indexOf(delim)+1, 
						param.indexOf(delim, param.indexOf(delim)+1)
						)));
				reciever.setZ(Double.parseDouble(param.substring(
						param.indexOf(delim, param.indexOf(delim)+1)+1, 
						param.length()-1
						)));
			}
			else if(line.startsWith("recieverRadius")){
				recieverRadius = Double.parseDouble(param);				
			}
			else if(line.startsWith("velRail")){
				velRail = Double.parseDouble(param);				
			}
			else if(line.startsWith("probDrail")){
				probDrail = Double.parseDouble(param);				
			}
			else if(line.startsWith("plusEndCentre")){
				microtubule = new MicroTubule();
				microtubule.setPlusEndCentre(new Position());
				listOfMicroTubule.add(microtubule);
				microtubule.getPlusEndCentre().setX(Double.parseDouble(param.substring(1,param.indexOf(delim))));
				microtubule.getPlusEndCentre().setY(Double.parseDouble(param.substring(
						param.indexOf(delim)+1, 
						param.indexOf(delim, param.indexOf(delim)+1)
						)));
				microtubule.getPlusEndCentre().setZ(Double.parseDouble(param.substring(
						param.indexOf(delim, param.indexOf(delim)+1)+1, 
						param.length()-1
						)));
			}
			else if(line.startsWith("minusEndCentre")){
				microtubule.setMinusEndCentre(new Position());
				microtubule.getMinusEndCentre().setX(Double.parseDouble(param.substring(1,param.indexOf(delim))));
				microtubule.getMinusEndCentre().setY(Double.parseDouble(param.substring(
						param.indexOf(delim)+1, 
						param.indexOf(delim, param.indexOf(delim)+1)
						)));
				microtubule.getMinusEndCentre().setZ(Double.parseDouble(param.substring(
						param.indexOf(delim, param.indexOf(delim)+1)+1, 
						param.length()-1
						)));
			}
			else if(line.startsWith("radiusMicroTubule")){
				microtubule.setRadiusMicroTubule(Double.parseDouble(param));				
			}
			else if (line.startsWith("radiusOfMolecule")){
				radius = Double.parseDouble(param);
			}
			
			else if (line.startsWith("OutputFile On")){
				generateOutputFile = true;
			}
			
		}
		br.close();

		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public double getMediumLength() {
		return mediumLength;
	}

	public double getMediumWidth() {
		return mediumWidth;
	}

	public double getMediumHeight() {
		return mediumHeight;
	}

	public ArrayList<MoleculeParams> getAllMoleculeParams() {
		return moleculeParams;
	}

	//am I understanding these getParams methods correctly?
	public ArrayList<MoleculeParams> getNoiseMoleculeParams() {
		ArrayList<MoleculeParams> noiseMParams = new ArrayList<MoleculeParams>();
		for (MoleculeParams mp : moleculeParams){
			if (mp.getMoleculeType().equals(MoleculeType.NOISE)){
				noiseMParams.add(mp);
			}
		}
		return noiseMParams;
	}

	public ArrayList<MoleculeParams> getInformationMoleculeParams() {
		ArrayList<MoleculeParams> infoMParams = new ArrayList<MoleculeParams>();
		for (MoleculeParams mp : moleculeParams){
			if (mp.getMoleculeType().equals(MoleculeType.INFO)){
				infoMParams.add(mp);
			}
		}
		return infoMParams;
	}

	public ArrayList<MoleculeParams> getAcknowledgmentMoleculeParams() {
		ArrayList<MoleculeParams> ackMParams = new ArrayList<MoleculeParams>();
		for (MoleculeParams mp : moleculeParams){
			if (mp.getMoleculeType().equals(MoleculeType.ACK)){
				ackMParams.add(mp);
			}
		}
		return ackMParams;
	}

	public ArrayList<Position> getTransmitterPositions() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public ArrayList<Position> getReceiverPositions() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public ArrayList<Position> getIntermediateNodePositions() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public ArrayList<Position> getMicrotubulePlusEndPoints() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public ArrayList<Position> getMicrotubuleMinusEndPoints() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public double getTransmitterRadius() {
		return transmitterRadius;
	}

	public double getReceiverRadius() {
		return receiverRadius;
	}

	public double getIntermediateNodeRadius() {
		return intermediateNodeRadius;
	}

	public ArrayList<Double> getMicrotubuleRadii() {
		return microtubuleRadii;
	}

	public int getNumRetransmissions() {
		return numRetransmissions;
	}

	public int getRetransmitWaitTime() {
		return retransmitWaitTime;
	}

	public boolean isUsingCollisions() {
		return useCollisions;
	}

	public boolean isUsingAcknowledgements() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public double getMolRandMoveX() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public double getMolRandMoveY() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public double getMolRandMoveZ() {
		throw new UnsupportedOperationException("The method is not implemented yet.");
	}

	public double getVelRail() {
		return velRail;
	}

	public double getProbDRail() {
		return probDRail;
	}

}
